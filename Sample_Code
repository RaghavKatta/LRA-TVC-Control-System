// Insert Code for different devices on here

// BMP 388
   ~ in progress
// SD Card
   ~ in progress
   https://cdn-learn.adafruit.com/downloads/pdf/adafruit-micro-sd-breakout-board-card-tutorial.pdf -> might work because it's for the breakout board that we have
   or maybe this https://forum.pjrc.com/threads/70142-External-SD-card-on-Teensy-4-1
// MPU 6050/GY-521 IMU
   ~ in progress
// MOSFET 
   ~from what I read, we don't need extra code for flash memory, we just need to include the library so we can 
    use the read/write features. It'll just sorta play a role in when we right down the code for everything else. 
// PID Calc
needs physical values to fully run
// Inertia 
done/needs checking
//gets an input of time, depending on what that value is, calculates the percent of fuel
//taken up and then multiplies that by the inertia difference and adds to the final 
//this allows it to model the curve between the starting and ending inertia appropriately
double Inertia(time) {
   //time in ms
   // check my math on this, I put the base equations in the notes
   //Inertia_difference is the difference between initial and final inertia
   //fuel fraction is the integral of the fuel used up, but it's not divided yet
   //we have to do that at the end which is why it is divided by 961.8 at end
   t = time/1000;
   fuel_fraction = 0;
   if t< .125 {
       fuel_fraction =  166 * pow(t,2)-1300*(pow(t,3)/3+pow(t,2)/8+t/64; 
   }
   else if t < 2.125 {
       fuel_fraction = 1015/4 * t - 15 * pow(t,2) + 3.8567708333;
   }
   else if t < 3.5 {
       fuel_fraction = 51.271-t⋅(36t−1673)/8;
   }
   else if t < 5.4 {
       fuel_fraction = -322.26 + 2113*t/5−35*pow(t,2);
   }
   else if t < 6.4 {
       fuel_fraction = 56.813 + 223*t/5−44(pow(t,2)/2−27*t/5);
   }
   else {
       fuel_fraction = 961.8
   }

   return Inertia_difference * fuel_fraction/961.8  + Final_inertia;
}

// Servos 

//initialize servo objects
Servo servo_innerloop;
Servo servo_outerloop;

void setup() {
   servo_innerloop.attach(pin # the servo is attached to)
   servo_innerloop.write(angle that makes the computer horiontal) 
   servo_outerloop.attach(pin # the servo is attached to)
   servo_outerloop.write(angle that makes the computer horiontal) 
   //ideally we'd want the servo's attached such that this angle is near the middle of the range
}

void loop() {
   innerloop_val = PID(noseangle_x);
   //we have to add the initial value, because the PID is tuned in such
   //a way that the initial angle is 0 and it'll go + or - to switch directions
   servo_innerloop.write(innerloop_val+initial value);
   
   outerloop_val = PID(noseangle_x);
   servo_outerloop.write(outerloop_val+initial value);
}

// Reaction Wheel
double pid(roll)
{
    proportional = roll;
    if (output < critical value) 
    {
        integral += roll * dt;
    }
    output = (kp * proportional) + (ki * integral);
}

//Pid output conversion
double conversion(θpid) 
{
    //have all the variables be defined globally at the start
    τpid = r*F*sin(θpid); 
    αdesired = τpid/Ipid;
    αdesired * I(t) = τdesired; 
    τfinal = τdesired - τgravity; 
    θfinal = arcsin(τfinal/rF); 
    return θfinal;
}
//Parachute Checking Conditions
boolean checkParachute(altitude, velocity, acceleration) {
     boolean condition = false;
     if(velocity <= 0 && acceleration <= 20) {
         condition = true;
     }
     else if(altitude < prevaltitude && acceleration <= 20){
         condition = true;
     }
     return condition;
}

//Gimbal Pi control that ignores the change in inertia
      same thing as reaction wheel basically, except error = angle in the direction we care about(x/y)

//make the same thing with y(instead of x, and y, it'd basically be our pitch and yaw, BUT we have to make sure that it's aligned with our sensors)
double pid(θ_x)
{
    proportional_gimbal_x = θ_x;
    if (output_gimbal_x < critical_value_gimbal) 
    {
        integral_gimbal_x += θ_x * dt;
    }
    output_x = (kp_gimbal * proportional_gimbal_x) + (ki_gimbal * integral_gimbal_x);
}

// Add as you think of it
