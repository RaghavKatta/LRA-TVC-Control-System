# What kind of system are we working with: 
 1. Non-Linear [linearized system, adjust via inertia stuff
 2. Minimum Delay 
 3. Closed Loop System
 4. Requirements: Reduce Windup Error, Cascading PID Control, Variant Subsystem Heirarchy 
[this last one is mostly to model in simulink, doesnt affect code]
[raghav's edits in brackets btw-unreliable af-i'll write in psuedo code just to express idea]
{navya's pseudocode}
{We NEED to account for redundancy + emergency deployment of parachutes + edge cases}
#

# PID Values Calculation:
  P --> 
  I --> 
  D -->
[will figure out via the advanced tuning method and/or simulink]
#

# Pre-Launch Requirements
  1. Check Communication with Flight Computer
  2. Check that there is power to all components
  3. Sensors are fucntioning 
  4. Launch Commands cued
[we put this in the setup part of the code right?
we just run conditions/check the feedback
a bunch of if commands that make sure the signal isn't null with each of the sensors?]
{This part of the code would be more asking all the systems to return data before laucnh/blink the signal lights that indicate that they are in fact working.
and then we have to write a command sequence for what happens when we give the rocket the green light to go (we have to figure out what real time interfacing 
with the rocket is going to look like / if we are going to have to design a UI to communicate with the rocket so we can get data on it right before + when we press
launch + while it's in the air}
#

# Powered Flight
  1. Sensor Feedback: altitude, velocity, acceleration 
  2. PID Tuning based on wind + other disturbances
[Variables calculations we need
*the values from the sensors are gonna be broken down, so it's not at straightforward as calling the value but it still shouldn't be that bad, ez 
to look up*
altitude- we take barometer reading and use the equation in notes to convert(only mainly needed for parachute deployment so its not that deep)
altitude = 44330*[1-(pressure/1013.25)^(1/5.225)
https://www.youtube.com/watch?v=rabWc5W84ug  - video tutorial

acceleration - straight from imu
https://randomnerdtutorials.com/arduino-mpu-6050-accelerometer-gyroscope/#:~:text=The%20MPU%2D6050%20measures%20acceleration,and%20pitch%20angles%20using%20trigonometry.

velocity - {shouldn't it be the integral of acceleration ? } derivative of acceleration(can take tiny time steps like 10ms and track a at each value and do += at, each time, effectively doing a
rieman sum to approximate velocity
*in the loop every 10 ms
v += a*.01

roll - the gyroscope should give the data across 3 axis, one of which will align with the rocket so it should be direct here
we can measure this by finding roll in the xy plane, gives rotation along z axis, look at diagram in notes for more understanding, math is provided there too
mind the dthete/dtime
https://www.youtube.com/watch?v=ythjrfQViRQ

nose cone angle - we'd have to integrate the values we get from gyroscope(like velocity) {Probably going to end up being the Vxz or Vxy value} 
***we can split this across x and y axis that aligns with our motors so we can process them seperately (seperate PIDs with same code)*** {I'm not sure this would 
be necessary cause the nose cone angle is the roll value across the x/y axis with respect to the z axis}
find the overall theta 
https://www.youtube.com/watch?v=ythjrfQViRQ - should be the yaw and pitch angles. 
{https://www.instructables.com/Accelerometer-Gyro-Tutorial/ --> this article details how to convert accelerometer and gyro values into something that we 
can work with. Also depending on the physical position of the gyro and the accelerometer we have to determine if the outputs for the gyro have to be inverted}
Nose_cone_angle_X = angular_velocity_x* .01 (same with y after)

gimbal angle - this would be what we send to the actuators that gimbal. 
this is the after affect of the PID controls 
output from the PI control system to the actuators
{We need to write code that determine the angle of the nozzle from actuator position -->
feeds it into PID --> PID outputs angle --> we turn angle into actuator outputs}
time - i'm assuming the computer alr tracks this? {Most likely --> definitely something I need to look into for Teensy functions}

Inertia - as a function of time, gotta figure this out before hand 
Must calculate before hand(looking at burn rate for engine, find burn rate for our engine)
]
#

# Parachute Flight
  1. Determining Statement that deploys parachute
  2. Sensors used to determine it's descent path + potential landing point {Sensors will just tell us where to expect it for recovery (not to plan descent path)
  Because we will plan approx. descent path beforehand}
[I don't think we use sensors to make a decent path back, i think it's just releasing the parachute on the massive field
the determining condition is prob(if rocket altitude goes down for half a second + the acceleration is less than 20 m/s to make sure
it doesn't prematurely fire while the rocket is going
*maybe check every half second
*we can have 2 checkpoints in case something malfunctions
if velocity <= 0 and acceleration <= 20:
  deploy parchute
else if altitude < (altitude 1 second ago) and acceleration <=20:
  deply parachute
]
{I think it should be based off of our altitude and we calculate acceleration and velocity that the rocket should have at that altitude}
# 

#
[actual code sections:
1.we need code to do all the variable calculations, make them save as global variables
     Listed above 
2.Reaction Wheel PI control
     //error is the roll value from gyroscope
     {error should be the change in the angle abt the x and y axis with respect to z from the gyro (alternating x and y values should indicate this) --> depending
      on how fast these values are changing we can determine rev/sec and output the counter to that}
     double pid(double error)
     {
       double proportional = error;
       integral += error * dt;
       double output = (kp * proportional) + (ki * integral);
       if output > critical value:
          output = critical value;
          integral -= error * dt;
       //this is just to prevent windup. We get it to stop integrating so the value doesn't increase further past a critical point
       //can prob make this more efficient but still is kinda the starting point 
       return output;
     }

3.Gimbal Pi control that ignores the change in inertia
      same thing as reaction wheel basically, except error = angle in the direction we care about(x/y)

4.The conversion of that into the proper value accounting for inertia(equations on the ppt for dcr)
   double conversion(θpid)
   {
      τpid = rFsin(θpid); {Force here is thrust at a given point)    
      αdesired = τpid/Ipid;
      αdesired * I(t) = τdesired; {This torque needs to be inverted to get the angle we need to coutneract the torque that has already rotated the rocket}
      τfinal = τdesired - τgravity; {Shouldn't you add torque gravity cause gravity is technically contributing to the downards pull so we need to counter it too}
      θfinal = sin^-1(τfinal/rF); {arcsin or 1/sin?}
      return θfinal;
    }

5.Converting that gimbal pi control output into values for the actuators/rotation wheel thingies or whatever 
    if it's a rotation wheel thingy, we can basically directly feed in the angle and it should rotate
6.checking for parachute condition values 
    code is above
I think that's it but I probably missed smth
]
#

